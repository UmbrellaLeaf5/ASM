В большинстве случаев инструкции MOV
изменяют только определенные байты регистра или ячейки памяти, соответствующие
операнду-приемнику. Единственным исключением является инструкция movl, которая, получая полный регистр в качестве приемника, запишет 0 в старшие 4 байта. Это
исключение возникает из соглашения, принятого в x86-64, согласно которому любая
инструкция, генерирующая 32-разрядное значение для регистра, также записывает 0 в
старшую половину регистра.

В большинстве случаев инструкции MOV
изменяют только определенные байты регистра или ячейки памяти, соответствующие
операнду-приемнику. Единственным исключением является инструкция movl, которая, получая полный регистр в качестве приемника, запишет 0 в старшие 4 байта. Это
исключение возникает из соглашения, принятого в x86-64, согласно которому любая
инструкция, генерирующая 32-разрядное значение для регистра, также записывает 0 в
старшую половину регистра.

MOVZ заполняют нулями оставшиеся байты в операнде-приемнике,
а инструкции в классе MOVS расширяют знак, копируя самый старший бит операнда-источника.

Обратите внимание на отсутствие в табл. 3.4 инструкции, перемещающей 4-байтное исходное значение в 8-байтный приемник. Логично было бы предположить, что
такая инструкция будет называться movzlq, но ее не существует. По этой причине такой вид перемещения данных можно реализовать с использованием инструкции movl
с регистром в роли операнда-приемника.

В табл. 3.5 также представлена инструкция cltq. Она не имеет операндов и всегда
перемещает данные из регистра %eax и в регистр %rax с расширением знакового разряда. Как следствие она дает тот же эффект, что и инструкция movslq %eax, %rax, но имеет
более компактное представление в коде.