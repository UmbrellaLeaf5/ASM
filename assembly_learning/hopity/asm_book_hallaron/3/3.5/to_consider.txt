В качестве иллюстрации использования leaq в скомпилированном коде рассмотрим
следующую программу на C:
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}

Арифметические операции внутри функции компилируются в последовательность
из трех инструкций leaq, описываемых в комментариях справа:

    long scale(long x, long y, long z)
    x в %rdi, y в %rsi, z в %rdx
scale:
    leaq (%rdi,%rsi,4), %rax x + 4*y
    leaq (%rdx,%rdx,2), %rdx z + 2*z = 3*z
    leaq (%rax,%rdx,4), %rax (x+4*y) + 4*(3*z) = x + 4*y + 12*z
    ret

Способность инструкции leaq выполнять сложение и ограниченные формы умножения часто используется для вычисления простых арифметических выражений, таких
как в этом примере.

Операции сдвига

Завершающая группа операций – операции сдвига, в которых величина сдвига определяется первым, а сдвигаемое значение – вторым операндом. Сдвиг вправо может быть
арифметическим или логическим. В разных инструкциях величина сдвига может определяться
константой или однобайтным регистром %cl. (Необычность этих инструкций в
том, что они позволяют использовать в роли операнда только этот конкретный регистр.)
Использование одного байта для представления величины сдвига позволяет закодировать величину сдвига в диапазоне от 0 до 28
 – 1 = 255.

Инструкция          Эффект                              Описание

imulq S, D          R[%rdx]:R[%rax] ← S × R[%rax]       Полное умножение со знаком

mulq S              R[%rdx]:R[%rax] ← S × R[%rax]       Полное умножение без знака

cqto                R[%rdx]:R[%rax] ← R[%rax]           Преобразование в восьмерное слово
                    (с расширением знака)

idivq S             R[%rdx] ← R[%rdx]:R[%rax] mod S;    Деление со знаком
                    R[%rax] ← R[%rdx]:R[%rax] ÷ S

divq S              R[%rdx] ← R[%rdx]:R[%rax] mod S;
                    R[%rax] ← R[%rdx]:R[%rax] ÷ S

В большинстве приложений 64-разрядного деления делимое передается как 64-разрядное значение. Значение делимого нужно сохранить в регистре %rax. Затем во все
биты %rdx записать нули (арифметика без знака) или знаковый бит из %rax (арифметика
со знаком). Последнюю операцию можно выполнить с помощью инструкции cqto2
. Эта инструкция не принимает операндов и просто извлекает знаковый бит из %rax и копирует его во все биты в %rdx.

void remdiv(long x, long y, long *qp, long *rp)
{
    long q = x/y;
    long r = x%y;
    *qp = q;
    *rp = r;
}

Она компилируется в следующий ассемблерный код:
    void remdiv(long x, long y, long *qp, long *rp)
    x в %rdi, y в %rsi, qp в %rdx, rp в %rcx
remdiv:
    movq %rdx, %r8 Скопировать qp
    movq %rdi, %rax Переместить x в младшие 8 байт делимого
    cqto Расширить знак в старшие 8 байт делимого
    idivq %rsi Разделить на y
    movq %rax, (%r8) Сохранить частное в qp
    movq %rdx, (%rcx) Сохранить остаток в rp
    ret