Переход может быть прямым, когда адрес перехода указан непосредственно
в коде самой программы, или косвенным, когда адрес перехода извлекается
из какого-нибудь регистра или из ячейки памяти.
Прямые переходы записываются
на языке ассемблера с указанием метки, обозначающей адреса перехода,
такой как .L1 в листинге выше. Косвенные переходы записываются со
звездочками (*), за которыми следует описатель операнда в формате,
как показано в табл. 3.2. Например, инструкция

jmp *%rax

использует значение, хранящееся в регистре %rах как адрес перехода,
а инструкция

jmp *(%rax)

извлекает адрес перехода из ячейки памяти,
на которую ссылается регистр %rax.


Чтобы понять, как условные операции могут быть реализованы с использованием
условной передачи данных, рассмотрим следующую общую форму условного выражения и присваивания:

v = условное-выражение ? выражение-then : выражение-else;

Стандартный способ компиляции этого выражения с использованием условной передачи управления будет иметь следующую форму:

if (!условное-выражение)
    goto false;
v = выражение-then;
goto done;
false:
    v = выражение-else;
done:

Этот код содержит две последовательности кода: одна вычисляет выражение-then, а
другая – выражение-else. Для вычисления только одной из последовательностей используется комбинация из условного и безусловного переходов.

Код, использующий условное перемещение, вычисляет оба выражения, выражениеthen и выражение-else, причем окончательный результат выбирается на основе оценки
условного-выражения. Это можно описать следующим абстрактным кодом:

v = выражение-then;
ve = выражение-else;
t = условное-выражение;
if (!t) v = ve;

Последний оператор в этой последовательности реализуется условным перемещением – значение ve копируется в v, только если не выполняется условие t.


В качестве еще одной иллюстрации рассмотрим следующую функцию на C:

long cread(long *xp)
{
    return (xp ? *xp : 0);
}

На первый взгляд она кажется хорошим кандидатом для компиляции с использованием условного перемещения, чтобы вернуть 0, когда указатель имеет значение NULL,
как показано в следующем ассемблерном коде:

    long cread(long *xp)
    Неправильная реализация функции cread
    xp в регистре %rdi
cread:
    movq (%rdi), %rax       v = *xp
    testq %rdi, %rdi        Проверить xp
    movl $0, %edx           Установить ve = 0
    cmove %rdx, %rax        Если xp==0, то v = ve
    ret                     Вернуть v

Однако эта реализация неверна, потому что разыменование xp инструкцией movq
(строка 2) происходит, даже если условие не выполняется, вызывая ошибку разыменования пустого указателя. Вместо этого данный код должен компилироваться с использованием ветвления управления.



ZA-LOOPS



Циклы do-while
Общая форма цикла do-while имеет следующий вид:

do
    тело-цикла
while (условное-выражение);

Эту общую форму можно преобразовать в условные выражения и операторы goto
следующим образом:

loop:
    тело-цикла
    t = условное-выражение;
    if (t)
    goto loop;

Циклы while:

Первый способ, который мы называем переходом в середину, выполняет начальную
проверку, производя безусловный переход к проверке в конце цикла. Это можно выразить в виде следующего шаблона в форме goto-кода:
    goto test;
loop:
    тело-цикла
test:
    t = условное-выражение;
    if (t)
    goto loop;

Второй способ, который мы называем защищенным-do, заключается в преобразовании кода в цикл do-while
и использовании условного ветвления, чтобы пропустить тело цикла, если начальная проверка завершилась неудачей.
GCC следует этой стратегии при компиляции с более высокими уровнями оптимизации, например с параметром командной строки -O1.
Этот способ можно выразить в общей форме в виде следующего шаблона преобразования цикла while в цикл do-while:

t = условное-выражение;
if (!t)
    goto done;
do
    тело-цикла
while (условное-выражение);
done:

Вот как можно представить этот шаблон в виде goto-кода:
t = условное-выражение;
if (!t)
    goto done;
loop:
    тело-цикла
    t = условное-выражение;
    if (t)
        goto loop;
done:

ЦИКЛ FOR:

Стандарт языка С устанавливает (с одним исключением, о котором рассказывается в
упражнении 3.29), что поведение такого цикла можно описать с помощью цикла while,
как показано ниже:

    выражение-инициализации;
while (условное-выражение)
{
    тело-цикла
    выражение-обновления;
}

To есть сначала программа вычисляет выражение-инициализации. Затем входит в
цикл, где сначала вычисляет условное-выражение, и если условие выполняется,
то выполняет тело-цикла и потом выражение-обновления.
GCC генерирует ассемблерный код, следуя одной из двух стратегий трансляции цикла
while в зависимости от уровня оптимизации. Сначала рассмотрим goto-версию с переходом в середину:

    выражение-инициализации;
    goto test;
loop:
    тело-цикла
    выражение-обновления;
test:
    t = условное-выражение;
    if (t)
    goto loop;

а вот версия, полученная в результате применения стратегии защищенного-do:
    выражение-инициализации;
    t = условное-выражение;
    if (!t)
        goto done;
loop:
    тело-цикла
    выражение-обновления;
    t = условное-выражение;
    if (t)
        goto loop;
done:   



                __    __
               /  \  /  \
              /    \/    \
              \          /
               \ SWITCH:/
                \      /
                 \    /
                  \  /
                   \/

Таблица переходов – это массив, в котором i-й элемент
содержит адрес кода, реализующего действия, которые программа должна выполнить,
когда индекс принимает значение i. Программа ссылается на таблицу переходов,
чтобы определить адрес для инструкции перехода.

Оператор && используется для доступа к адресу метки (а жЫд не знает об этом хехехе)

Пример:

void switch_eg_impl(long x, long n,
long *dest)
{
    /* Таблица указателей на блоки кода */
    static void *jt[7] = {
    &&loc_A, &&loc_def, &&loc_B,
    &&loc_C, &&loc_D, &&loc_def,
    &&loc_D
    };
    unsigned long index = n - 100;
    long val;

    if (index > 6)
        goto loc_def;

    /* Множественное ветвление */
    goto *jt[index];

loc_A:          /* Вариант 100 */
    val = x * 13;
    goto done;
loc_B:          /* Вариант 102 */
    x = x + 10;
    /* проваливается далее */
loc_C: /* Вариант 103 */
    val = x + 11;
goto done;
loc_D: /* Варианты 104, 106 */
    val = x * x;
    goto done;
    loc_def: /* Вариант по умолчанию */
    val = 0;
done:
    *dest = val;
}

Листинг 3.9. Реализация на ассемблере оператора switch из листинга 3.22
    void switch_eg(long x, long n, long *dest)
    x <-> %rdi, n <-> %rsi, dest <-> %rdx
switch_eg:
    subq $100, %rsi             Вычислить index = n-100
    cmpq $6, %rsi               Сравнить index:6
    ja .L8                      Если >, перейти к loc_def
    jmp *.L4(,%rsi,8)           перейти к *jt[index]
.L3:                            loc_A:
    leaq (%rdi,%rdi,2), %rax    3 * x
    leaq (%rdi,%rax,4), %rdi    val = 13 * x
    jmp .L2                     перейти к done
.L5:                            loc_B:
    addq $10, %rdi              x = x + 10
.L6:                            loc_C:
    addq $11, %rdi              val = x + 11
    jmp .L2                     перейти к done
.L7:                            loc_D:
    imulq %rdi, %rdi            val = x * x
    jmp .L2                     перейти к done
.L8:                            loc_def:
    movl $0, %edi               val = 0
.L2:                            done:
    movq %rdi, (%rdx)           *dest = val
    ret                         Возврат

В ассемблерном коде таблица переходов объявляется следующим образом
(мы добавили дополнительные комментарии для ясности):

    .section .rodata
    .align 8 Выравнивать адреса по границам, кратным 8
.L4:
    .quad .L3           Вариант 100: loc_A
    .quad .L8           Вариант 101: loc_def
    .quad .L5           Вариант 102: loc_B
    .quad .L6           Вариант 103: loc_C
    .quad .L7           Вариант 104: loc_D
    .quad .L8           Вариант 105: loc_def
    .quad .L7           Вариант 106: loc_D