Для следующей программы на C
long loop_while2(long a, long b)
{
    long result = ________;
    while ( ________ )
    {
        result = ________;
        b = ________;
    }
    return result;
}

компилятор GCC, запущенный с параметром -O1, сгенерировал такой ассемблерный код:

    a <-> %rdi, b <-> %rsi
loop_while2:
    testq %rsi, %rsi
    jle .L8
    movq %rsi, %rax
.L7:
    imulq %rdi, %rax
    subq %rdi, %rsi
    testq %rsi, %rsi
    jg .L7
    rep; ret
.L8:
    movq %rsi, %rax
    ret

Как видите, компилятор использовал способ защищенный-do, сгенерировав инструкцию
jle в строке 3, чтобы пропустить цикл, если начальная проверка завершится неудачей.
Заполните недостающие фрагменты в коде на C. Обратите внимание, что структура управления
в ассемблерном коде не совсем соответствует структуре в goto-коде, полученном путем
прямого воссоздания кода на C в соответствии с нашими правилами. В частности, в нем
присутствуют две разные инструкции ret (строки 10 и 13). Однако вы должны восстановить
недостающие фрагменты в коде на C, чтобы он имел поведение, эквивалентное поведению
ассемблерного кода.

__________________________________________________________________________________

long loop_while2(long a, long b)
{
    long result = b;
    while (b > 0)
    {
        result = result*a;
        b = b - a;
    }
    return result;
}