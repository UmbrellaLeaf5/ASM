Имеется функция fun_b со следующей структурой:

long fun_b(unsigned long x)
{
    long val = 0;
    long i;
    for ( ... ; ... ; ... )
    {
        ...
    }
    return val;
}

Компилятор GCC сгенерировал следующий ассемблерный код:

    long fun_b(unsigned long x)
    x <-> %rdi
fun_b:
    movl $64, %edx
    movl $0, %eax
.L10:
    movq %rdi, %rcx
    andl $1, %ecx       # temp = x&1
    addq %rax, %rax     # val *= 2;
    orq %rcx, %rax      # val = val|temp;
    shrq %rdi           # x >>= 1           Сдвиг вправо на 1
    subq $1, %rdx       # --i;
    jne .L10            
    rep; ret

Воссоздайте версию на С из этого кода, а затем:
(1) опираясь на ассемблерную версию, восстановите недостающие фрагменты в коде на C;
(2) объясните, почему отсутствует начальная проверка условия перед циклом и начальный
переход к проверке в конце цикла;
(3) опишите простым языком, что вычисляет эта функция.

__________________________________________________________________________________

1.
long fun_b(unsigned long x)
{
    long val = 0;
    long i;
    for ( i = 64 ; i != 0 ; --i; )
    {
        val = ((2*val) | x&1 );
        x >>= 1
    }
    return val;
}

2. Потому что известно заранее, что цикл выполнится хотя бы 1 раз (64 раза если быть точнее).

3. Получаем число, которое образованное двоичным представлением числа "x", прочитанным наоборот (100100 -> 001001 = 1001)